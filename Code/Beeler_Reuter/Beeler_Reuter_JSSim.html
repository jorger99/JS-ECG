<!DOCTYPE html>
<script src='https://abubujs.org/libs/AkPlot.latest.js'></script>
<script src='https://abubujs.org/libs/Abubu.latest.js'></script>

<html>
<center> <h1> Numerical Analysis of Beeler-Reuter Model </h1> </center>

<body> <center>
  <canvas id="c1" width="512" height="512" style="border:1px solid #000000;">
  Your browser does not support the HTML5 canvas tag.</canvas><br>
	<canvas id="c2" width="512" height="256" style="border:1px solid #000000;">
	  Your browser does not support the HTML5 canvas tag.</canvas>
	<canvas id="c3" width="512" height="256" style="border:1px solid #000000;">
	  Your browser does not support the HTML5 canvas tag.</canvas>
</center> </body>

<script>

/*-------------------------------------------------------------------------
 * initialize our canvas and its useful variables
 *-------------------------------------------------------------------------
 */
  var cnvs = document.getElementById('c1') ;
	var cnvs2 = document.getElementById('c2') ;
	var cnvs3 = document.getElementById('c3') ;

  var width = cnvs.width ;
  var height = cnvs.height ;

/*-------------------------------------------------------------------------
 * initialize our simulation variables
 *-------------------------------------------------------------------------
 */

// sim variables
var time 			=  0.  		 ;
var pltTime 	=  0. 		 ;
var dt 				=  0.02	   ;
var v_mem 		=  0.			 ;

// laplacian
var dx 				=  0.025   ;


// ion conductivities per unit area
var g_na 			=  4.0	   ;
var g_nac 		=  0.03 	 ;
var g_s 			=  0.09 	 ;

// reversal potentials
var e_na 			=  50.		 ;
var e_s 			=  0. 		 ;

// ion currents, used to calculate v_mem every step
var i_k1 			=  0.			 ;
var i_x1 			=  0. 		 ;
var i_na 			=  0. 		 ;
var i_s 		 	=  0. 		 ;

// variables for Rush-Larsen method, all set to 0 for usage in other functions\
var x1 = 0  , m = 0  , h = 0  , j = 0  , d = 0  , f = 0  ;   // gates
var a_x1 = 0, a_m = 0, a_h = 0, a_j = 0, a_d = 0, a_f = 0;   // alphas
var b_x1 = 0, b_m = 0, b_h = 0, b_j = 0, b_d = 0, b_f = 0;   // betas

// initial value of membrane voltage
//var v_resting = -60.  	;

// store variables in env
env = {
	skip 			: 1 ,
	running 	: true ,
	solve 		: function(){ env.running = !env.running ; } ,
} ;

/*-------------------------------------------------------------------------
 * Beeler-Reuter Model functions of membrane voltage
 * each function represents a global variable that updates
 * based on current voltage and returns its value
 * ------------------------------------------------------------------------
 */

// base equation (no. 13 from paper) for every single alpha and beta,
// values for c1 through c7 are unique to each variable [page 181]
function rate_constant(v, c){
	// v is the input voltage, c is an array with parameters c1-c7
	return c[0]*Math.exp(c[1]*(v+c[2])) + c[3]*(v+c[4])/(Math.exp(c[5]*(v+c[2])+ c[6])) ;
} ;

// store the values of c[n-1] for c1-c7 for every alpha, table from page 181

// example:   alpha_n_constants = [c1, c2, c3, c4, c5, c6, c7]
// gives ---> alpha_n = rate_constant(v, alpha_n_constants)
let a_x1_const = [0.0005, 0.083, 50, 0, 0, 0.057, 1] 	;
let b_x1_const = [0.0013, -0.06, 20, 0, 0, -0.04, 1] 	;
let a_m_const  = [0, 0, 47, -1, 47, -0.1, -1] 				;
let b_m_const  = [40, -0.056, 72, 0, 0, 0, 0] 				;
let a_h_const  = [0.126, -0.25, 77, 0, 0, 0, 0] 			;
let b_h_const  = [1.7, 0, 22.5, 0, 0, -0.082, 1] 			;
let a_j_const  = [0.055, -0.25, 78, 0, 0, -0.2, 1] 		;
let b_j_const  = [0.3, 0, 32, 0, 0, -0.1, 1] 	 				;
let a_d_const  = [0.095, -0.01, -5, 0, 0, -0.072, 1] 	;
let b_d_const  = [0.07, -0.017, 44, 0, 0, 0.05, 1]  	;
let a_t_const  = [0.012, -0.008, 28, 0, 0, 0.15, 1] 	;
let b_t_const  = [0.0065, -0.02, 30, 0, 0, -0.2, 1] 	;


// final function that will be useful to calculate the steady state value of a gate
function gate_inf(alpha, beta){
	return alpha/(alpha+beta)
} ;


/*-------------------------------------------------------------------------
 * define functions for simulation
 *-------------------------------------------------------------------------
 */

function update_alphas_betas(v){
	// this function will update every alpha and beta to be used
	// globally in other functions.. this is necessary to avoid
	// calculating them more than once per step

	// all alphas and betas are functions of the current voltage
	a_x1 = rate_constant(v, a_x1_const) ;
	a_m  = rate_constant(v, a_m_const)  ;
	a_h  = rate_constant(v, a_h_const)  ;
	a_j  = rate_constant(v, a_j_const)  ;
	a_d  = rate_constant(v, a_d_const)  ;
	a_t  = rate_constant(v, a_t_const)  ;

	b_x1 = rate_constant(v, b_x1_const) ;
	b_m  = rate_constant(v, b_m_const)  ;
	b_h  = rate_constant(v, b_h_const)  ;
	b_j  = rate_constant(v, b_j_const)  ;
	b_d  = rate_constant(v, b_d_const)  ;
	b_t  = rate_constant(v, b_t_const)  ;

} ;

function init_values(v_rest = -60){
	// calculate initial values of n,m,h using default resting voltage -60mV
	// update alphas and betas then calculate n, m, h
	update_alphas_betas(v_rest) ;

	x1 = gate_inf(a_x1, b_x1) ;
	m  = gate_inf(a_m, b_m) ;
	h  = gate_inf(a_h, b_h) ;
	j  = gate_inf(a_j, b_j) ;
	d  = gate_inf(a_d, b_d) ;
	f  = gate_inf(a_f, b_f) ;


} ;


function compute_step(){
	// make sure we only calculate alphas and betas
	// once using the current value of voltage,  v_mem
	update_alphas_betas(v_mem)

	// update gating variables with RL method	stepping
	// use the gate_inf to calculate tau since
	// gate_inf = a/a+b and tau = 1/a+b
	x1_inf = gate_inf(a_x1, b_x1) ;
	x1 = x1_inf + (x1 - x1_inf)*Math.exp(-dt/x1_inf*a_x1) ;

	m_inf = gate_inf(a_m, b_m) ;
	m	= m_inf + (m - m_inf)*Math.exp(-dt/m_inf*a_m) ;

	h_inf = gate_inf(a_h, b_h) ;
	h = h_inf + (h - h_inf)*Math.exp(-dt/h_inf*a_h)

	j_inf = gate_inf(a_j, b_j) ;
	j = j_inf + (j - j_inf)*Math.exp(-dt/j_inf*a_j)

	d_inf = gate_inf(a_d, b_d) ;
	d = d_inf + (d - d_inf)*Math.exp(-dt/d_inf*d_h)

	f_inf = gate_inf(a_f, b_f) ;
	f = f_inf + (f - f_inf)*Math.exp(-dt/f_inf*f_h)


	// update the currents
	i_k1 = 0.35*(4.0*(Math.exp(0.04*(v_mem+85))-1.0)/(Math.exp(0.08*(v_mem+53)) + Math.exp(0.04*(v_mem+53)))+0.2*(v_mem+23)/(1.0-Math.exp(-0.04*(v_mem+23)))) ;

	i_x1 	= 0.8*(Math.exp(0.04*(v_mem+77))-1.0)/Math.exp(0.04*(v_mem+35)) * x1 ;

	i_na	= g_na * (m*m*h*j+g_nac)*(v - e_na) ;

	ca  	= ca + dt*(-0.0000001 * i_s + 0.07*(0.0000001 - ca)) ;
	e_s   = -82.3 - 13.0287 * Math.log(ca) ;
	i_s 	= g_s * (d*f)*(v_mem - e_s) ;

	// external current is 0 for all t except in
	// the very beginning to stimulate the AP
	i_exter = 0. ;
	if(time<0.5){i_exter = -80.}

	// calculate our membrane voltage and update our time trackers
	v_mem = v_mem - dt*(i_k1 + + i_x1 + i_na + i_s + i_exter) + dt* [xxxx] ;

	// update our time variables
	time 		+= dt ;
	pltTime += dt ;

} ;

/*-------------------------------------------------------------------------
 * visuals (plots + GUI)
 *-------------------------------------------------------------------------
 */


 function createGUI(){
 var gui = new Abubu.Gui() ;
 var pnl = gui.addPanel() ;

 pnl.add( env, 'init').name( 'Initialize Solution' ) ;
 pnl.add( env, 'solve').name( 'Solve/Pause' ) ;

}


/*-------------------------------------------------------------------------
 * Plot one: Time vs V_membrane
 *-------------------------------------------------------------------------
 */
// initialize plot settings then make function to update it
var plt1 = new Plot(cnvs) ;
var plt_xmax = 30

plt1.grid = 'on' ;

plt1.xlimits = [0, plt_xmax] ;    		// time axis 		[s]
plt1.ylimits = [-80, 60] ; 		// voltage axis [mV]

// ticks
plt1.xticks.precision = 0 ;
plt1.yticks.precision = 1 ;

plt1.xticks.noDivs = 5 ;
plt1.yticks.noDivs = 7 ;

// setting up legend
plt1.legend.visible = true ;
plt1.legend.location = [c1.width-100, 30]

// font settings
plt1.legend.font = '12pt Times' ;
plt1.borders = 'on' ;
plt1.margins.left = 80 ;

plt1.xlabel = 'Time [ms]' ;
plt1.ylabel = 'Voltage [mV]' ;

/*
var n_curve = plt1.addCurveFromPoints() ;
n_curve.name= 'n' ;
var m_curve = plt1.addCurveFromPoints() ;
m_curve.name= 'm' ;
var h_curve = plt1.addCurveFromPoints() ;
h_curve.name= 'h' ;
*/

var v_curve = plt1.addCurveFromPoints() ;
v_curve.name='v_mem' ;

// begin the PLOT
plt1.init() ;

/*-------------------------------------------------------------------------
 * Plot Two: Time vs. Gating Variables
 *-------------------------------------------------------------------------
 */

/*
 var plt2 = new Plot(cnvs2) ;

 plt2.grid = 'on' ;

 plt2.xlimits = [0, plt_xmax] ;    		// time axis 		[s]
 plt2.ylimits = [0, 1] ; 		// voltage axis [mV]

 // ticks
 plt2.xticks.precision = 0 ;
 plt2.yticks.precision = 1 ;

 plt2.xticks.noDivs = 5 ;
 plt2.yticks.noDivs = 9 ;

 // setting up legend
 plt2.legend.visible = true ;
 plt2.legend.location = [c1.width-100, 30]

 // font settings
 plt2.legend.font = '12pt Times' ;
 plt2.borders = 'on' ;
 plt2.margins.left = 80 ;

 plt2.xlabel = 'Time [???]' ;
 plt2.ylabel = 'Gating Variable [a.u.]' ;

 var n_curve = plt2.addCurveFromPoints() ;
 n_curve.name= 'n' ;
 var m_curve = plt2.addCurveFromPoints() ;
 m_curve.name= 'm' ;
 var h_curve = plt2.addCurveFromPoints() ;
 h_curve.name= 'h' ;

 // begin the PLOT
 plt2.init() ;

*/

 /*-------------------------------------------------------------------------
  * Plot Three: Time vs. Ionic Currents
  *-------------------------------------------------------------------------
  */

var plt3 = new Plot(cnvs3) ;

plt3.grid = 'on' ;

plt3.xlimits = [0, plt_xmax] ;    		// time axis 		[s]
plt3.ylimits = [-.8, .8] ; 		// voltage axis [mV]

// ticks
plt3.xticks.precision = 0 ;
plt3.yticks.precision = 1 ;

plt3.xticks.noDivs = 5 ;
plt3.yticks.noDivs = 8 ;

// setting up legend
plt3.legend.visible = true ;
plt3.legend.location = [c1.width-100, 30]

// font settings
plt3.legend.font = '12pt Times' ;
plt3.borders = 'on' ;
plt3.margins.left = 80 ;

plt3.xlabel = 'Time [???]' ;
plt3.ylabel = 'Voltage [V]' ;

var ik1_curve = plt3.addCurveFromPoints() ;
ik1_curve.name= 'i_k1' ;
var ix1_curve = plt3.addCurveFromPoints() ;
ix1_curve.name= 'i_x1' ;
var ina_curve = plt3.addCurveFromPoints() ;
ina_curve.name= 'i_na' ;
var is_curve = plt3.addCurveFromPoints() ;
is_curve.name= 'i_s' ;
var iexter_curve = plt3.addCurveFromPoints() ;
iexter_curve.name= 'i_exter' ;

plt3.init()

function update_plots(){
	// shift x axis to right as time goes on
	if(pltTime>plt_xmax){
			// reset value of pltTime
			pltTime-=plt_xmax ;

			// shift x axes to the right by pltTime amount and reset
			plt1.xlimits = [plt1.xlimits[0]+plt_xmax, plt1.xlimits[1]+plt_xmax] ;
			//plt2.xlimits = [plt2.xlimits[0]+plt_xmax, plt2.xlimits[1]+plt_xmax] ;
			plt3.xlimits = [plt3.xlimits[0]+plt_xmax, plt3.xlimits[1]+plt_xmax] ;


			plt1.reset() ;
			//plt2.reset() ;
			plt3.reset() ;
	}

	// plot 1
	v_curve.draw(time, v_mem)

	/* plot 2
	n_curve.draw(time, n) ;
	m_curve.draw(time, m) ;
	h_curve.draw(time, h) ;
	*/

	// plot 3
	ik1_curve.draw(time, i_k1/1000) ;
	ix1_curve.draw(time, i_x1/1000) ;
	ina_curve.draw(time, i_na/1000) ;
	is_curve.draw(time, i_s/1000) ;
	iexter_curve.draw(time, i_exter/1000) ;

} ;


/*-------------------------------------------------------------------------
 * run simulation
 *-------------------------------------------------------------------------
 */

function run(){
	 if (env.running){
			 compute_step() ;
			 update_plots() ;
			 // if(pltTime%500==0){console.log(v_mem)}
	 }
	 setTimeout(run, 10)  // call run() function with delay
} ;

init_values() ;

run() ;




</script>
